\documentclass[english,notitlepage,reprint]{revtex4-1}  % defines the basic parameters of the document

% if you want a single-column, remove reprint

% allows special characters (including æøå)
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

%% note that you may need to download some of these packages manually, it depends on your setup.
%% I recommend downloading TeXMaker, because it includes a large library of the most common packages.

\usepackage{physics,amssymb}  % mathematical symbols (physics imports amsmath)
\usepackage{graphicx}         % include graphics such as plots
\usepackage{xcolor}           % set colors
\usepackage{hyperref}         % automagic cross-referencing (this is GODLIKE)
\usepackage{tikz}             % draw figures manually
\usepackage{listings}         % display code
\usepackage{subfigure}        % imports a lot of cool and useful figure commands
\usepackage{lipsum}

\usepackage{lmodern}

% (2) specify encoding
\usepackage[T1]{fontenc}
\usepackage{textcomp}
%\usepackage{unicode-math}
\usepackage{float}
\usepackage{balance}

% defines the color of hyperref objects
% Blending two colors:  blue!80!black  =  80% blue and 20% black
\hypersetup{ % this is just my personal choice, feel free to change things
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}}

%% Defines the style of the programming listing
%% This is actually my personal template, go ahead and change stuff if you want
\lstset{ %
	inputpath=,
	backgroundcolor=\color{white!88!black},
	basicstyle={\ttfamily\scriptsize},
	commentstyle=\color{magenta},
	language=Python,
	morekeywords={True,False},
	tabsize=4,
	stringstyle=\color{green!55!black},
	frame=single,
	keywordstyle=\color{blue},
	showstringspaces=false,
	columns=fullflexible,
	keepspaces=true}

\lstset{literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}

%% USEFUL LINKS:
%%
%%   UiO LaTeX guides:        https://www.mn.uio.no/ifi/tjenester/it/hjelp/latex/
%%   mathematics:             https://en.wikibooks.org/wiki/LaTeX/Mathematics

%%   PHYSICS !                https://mirror.hmc.edu/ctan/macros/latex/contrib/physics/physics.pdf

%%   the basics of Tikz:       https://en.wikibooks.org/wiki/LaTeX/PGF/TikZ
%%   all the colors!:          https://en.wikibooks.org/wiki/LaTeX/Colors
%%   how to draw tables:       https://en.wikibooks.org/wiki/LaTeX/Tables
%%   code listing styles:      https://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings
%%   \includegraphics          https://en.wikibooks.org/wiki/LaTeX/Importing_Graphics
%%   learn more about figures  https://en.wikibooks.org/wiki/LaTeX/Floats,_Figures_and_Captions
%%   automagic bibliography:   https://en.wikibooks.org/wiki/LaTeX/Bibliography_Management  (this one is kinda difficult the first time)
%%   REVTeX Guide:             http://www.physics.csbsju.edu/370/papers/Journal_Style_Manuals/auguide4-1.pdf
%%
%%   (this document is of class "revtex4-1", the REVTeX Guide explains how the class works)


%% CREATING THE .pdf FILE USING LINUX IN THE TERMINAL
%%
%% [terminal]$ pdflatex template.tex
%%
%% Run the command twice, always.
%% If you want to use \footnote, you need to run these commands (IN THIS SPECIFIC ORDER)
%%
%% [terminal]$ pdflatex template.tex
%% [terminal]$ bibtex template
%% [terminal]$ pdflatex template.tex
%% [terminal]$ pdflatex template.tex
%%
%% Don't ask me why, I don't know.

\usepackage{thmtools}
\DeclareMathOperator{\nullspace}{Nul}
\DeclareMathOperator{\collspace}{Col}
\DeclareMathOperator{\rref}{Rref}
%%\DeclareMathOperator{\dim}{Dim}

 % "meq": must be equal
\newcommand{\meq}{\overset{!}{=}}

\newcommand{\R}{\mathbb{R}}
\newcommand*\Heq{\ensuremath{\overset{\kern2pt L'H}{=}}}
\usepackage{bm}
\newcommand{\uveci}{{\bm{\hat{\textnormal{\bfseries\i}}}}}
\newcommand{\uvecj}{{\bm{\hat{\textnormal{\bfseries\j}}}}}
\DeclareRobustCommand{\uvec}[1]{{%
  \ifcsname uvec#1\endcsname
     \csname uvec#1\endcsname
   \else
    \bm{\hat{\mathbf{#1}}}%
   \fi
}}
\usepackage{siunitx}

\makeatletter
\newcommand*{\balancecolsandclearpage}{%
  \close@column@grid
  \cleardoublepage
  \twocolumngrid
}
\makeatother

\newcounter{subproject}
\renewcommand{\thesubproject}{\alph{subproject}}
\newenvironment{subproj}{
\begin{description}
	\item[\refstepcounter{subproject}(\thesubproject)]
}{\end{description}}


\begin{document}
\title{Calculating eigenvalues using Jacobi's rotational algorithm}   % self-explanatory
\author{Anders P. Åsbø}               % self-explanatory
\date{\today}
\noaffiliation                            % ignore this

\begin{abstract}
This paper focused on the implementation, and application of Jacobi's rotational algorithm to find the eigenvalues of Tridiagonal matrices numerically. The physical problems considered were a buckeling beam, and both a single electron and two electrons trapped in a harmonic oscillator potential.

The goal is to evaluate the usability of the implementation, and look at possible improvements that can be made in future implementations of Jacobi's rotational algorithm.

The implementation of \hyperref[subsec:32]{Jacobi's algorithm} looked at in this paper, was able to calulate the eigenvalues of the \hyperref[subsec:21]{buckling beam} problem with high accuracy (\hyperref[tab:421]{table II}), but could only reproduce the eigenvalues of the \hyperref[subsec:23]{single-electron} problem within \(2\) leading decimals.

I was able to reproduce one of the results from Taut, M. (1993)\citep{PhysRevA.48.3561}. However, the reliability of this result is suspect at best.

Overall, my implementation of \hyperref[subsec:32]{Jacobi's algorithm} is not particularly resource efficient. There are several improvements that can be made in future implementations. It can be used somewhat reliably for problems with a finite maximum variable, for \(N \leq 200\), but require to be run on better hardware to allow higher \(N\) when necessary.
\end{abstract}

\maketitle
\tableofcontents

\section{Introduction}\label{sec:1}
The focus of this paper was the implementation, and application of Jacobi's rotational algorithm to find the eigenvalues of Tridiagonal matrices numerically. Reliably finding eigenvalues is a crucial part of many scientific and mathematical disciplines. The physical problems considered were a buckeling beam, and both a single electron and two electrons trapped in a harmonic oscillator potential.

The goal is to evaluate the usability of the implementation, and look at possible improvements that can be made in future implementations of Jacobi's rotational algorithm.

\section{Formalism}\label{sec:2}
\subsection{The buckling beam problem}\label{subsec:21}
The pretense for implementing Jacobi's algorithm is the classical problem of a beam of length \(L\) fastened in both ends \(x_{0} = 0\), \(x_{L} = L\). The beam is allowed to be displaced in the \(y\)-direction with displacement \(u(x)\), while \(u(0)=u(L)=0\). The displacement is driven by a force \(F\) at \((L,0)\) towards the origin. The displacement is then described by
$$
	\gamma \frac{d^{2}u(x)}{dx^{2}}=-Fu(x),
$$
where \(\gamma\) is a constant dependent on the physical properties of the beam\citep{DepartmentofPhysics2019}.

By scaling the differential equation with \(\rho = \frac{x}{L}\), such that \(\rho \in [0,1]\), and introducing the parameter \(\lambda = FL^{2}/\gamma\)\citep{DepartmentofPhysics2019}, the differential equation becomes
$$
	\frac{d^{2}u(\rho)}{d\rho^{2}}=-\lambda u(\rho).
$$

Finally, the equation can be discretized with
$$
	u'' \approx \frac{u(\rho+h)-2u(\rho)+u(\rho-h)}{h^{2}},
$$
where \(h = \frac{\rho_{N}-\rho_{0}}{N}\) with \(N\) steps\citep{DepartmentofPhysics2019}. The resulting discretization becomes
$$
	-\frac{1}{h^{2}}u_{i+1}+
	\frac{2}{h^{2}}u_{i}-\frac{1}{h^{2}}u_{i-1}=\lambda u_{i},
$$
which can be written as the matrix equation
$$
	A\vec{u}=\lambda\vec{u},
$$
where \(A\) is an \((N-2)\times (N-2)\) tridiagonal Toeplitz matrix with the diagonal elements \(d=2/h^{2}\), and upper and lower diagonals with elements \(a=-1/h^{2}\). This matrix happens to have analytical eigenvalues
$$
	\lambda_{j}=d+2a\cos\left(\frac{j\pi}{N+1}\right),
$$
where \(j=1,2,...,N\)\citep{DepartmentofPhysics2019}.

\subsection{The Jacobi rotational algorithm}\label{subsec:22}
The goal of the Jacobi rotational algorithm is to reduce a matrix \(A\) to a diagonal matrix \(B\) where the elements along the diagonal are the eigenvalues \(\lambda_{i}\) of \(A\). This is usually done by finding a matrix \(S\) such that
$$
	B = S^{T}AS,
$$
and \(S^{T}=S^{-1}\)\citep{Hjorth-Jensen2019}. The Jacobi algorithm achieves this by choosing the elements of \(S\) to be equal to the coresponding identity matrix, except for the elements \(s_{kk},s_{ll}=\cos\theta\) and \(s_{kl} = \pm \sin\theta\), \(s_{lk} = -s_{kl}\)\citep{Hjorth-Jensen2019}, and applying the \(B = S^{T}AS\) transformation repeatedly, until the non-diagonal elements of \(B\) are sufficiently close to zero. Doing this we get a system of equations for the various elements of the resulting matrix \(B\)
$$
	b_{ii}=a_{ii} i\neq k, i\neq l,
$$
$$
	b_{ik}=a_{ik}c-a_{il}s, i\neq k, i\neq l,
$$
$$
	b_{il}=a_{il}c+a_{ik}s, i\neq k, i\neq l,
$$
$$
	b_{kk}=a_{kk}c^{2}-2a_{kl}cs-a_{ll}s^{2},
$$
$$
	b_{ll}=a_{ll}c^{2}-2a_{kl}cs-a_{kk}s^{2},
$$
$$
	b_{kl}=\left(a_{kk}-a_{ll}\right)cs-a_{kl}\left(c^{2}-s^{2}\right),
$$
$$
	b_{lk}=-b_{kl},
$$
where \(c = \cos\theta\), \(s = \sin\theta\), and \(k,l\) are chosen such that \(a_{kl}\) is the non-diagonal element in \(A\) with the largest absolute value.

To chose an rotational angle \(\theta\), the quantities \(\tan\theta=t=s/c\) are defined such that
$$
	\cot 2\theta = \tau = \frac{a_{ll}-a_{kk}}{2a_{kl}},
$$
$$
	t = -\tau \pm \sqrt{1+\tau^{2}},
$$
$$
	c = \frac{1}{\sqrt{1+t^{2}}},
$$
$$
	s = ct,
$$
\citep{Hjorth-Jensen2019}.

\subsection{Eigenvalues of a one-electron Hamiltonian}\label{subsec:23}
To test the implementation of Jacobi's algorithm, as outlined in \autoref{subsec:22}, a quantum mechanical system consisting of an electron trapped in a radialy symetric harmonic oscillator potential \(V(r)=\frac{1}{2}mkr^{2}\) was chosen as a test case.
the corresponding radial equation is
$$
	-\frac{\hbar^{2}}{2m}\left(\frac{1}{r^{2}}\frac{d}{dr}r^{2}\frac{d}{dr}-\frac{l\left(l+1\right)}{r^{2}}\right)R(r)+V(r)R(r)=ER(r),
$$
where \(\hbar\) is Planck's constant, \(m\) is the electron mass, \(R(r)\) is the radial wavefunction,  and \(l=0,1,2,3,...\) is the orbital momentum of the electron\citep{DepartmentofPhysics2019}. By substituting in \(R(r) = (1/r)u(r)\), and introducing the scaled variable \(\rho = (1/\alpha)r\), where \(\alpha\) is some constant, the equation can be reduced to
$$
	-\frac{d^{2}}{d\rho^{2}}u(\rho)+\rho^{2}u(\rho)=\lambda u(\rho),
$$
where \(\alpha\) is chosen such that \(\frac{mk}{\hbar^{2}}\alpha^{4} = 1\), and
$$
	\lambda=\frac{2m\alpha^{2}}{\hbar^{2}}
$$
\citep{DepartmentofPhysics2019}.

After discretization as in \autoref{subsec:21}, the problem results in the system of linear equations
$$
	-\frac{1}{h^{2}}u_{i+1}+
	\left(\frac{2}{h^{2}}+\rho^{2}\right)u_{i}-\frac{1}{h^{2}}u_{i-1}=\lambda u_{i},
$$
with the requirement that \(u(0)=u(\infty)=0\)\citep{DepartmentofPhysics2019}. This can be written as a matrix equation where the matrix \(A\) is a tridiagonal matrix with \(d = \left(\frac{2}{h^{2}}+\rho^{2}\right)\) along the diagonal, and \(e = -\frac{1}{h^{2}}\) as the non-diagonal elements. The step-size \(h\) is as defined in \autoref{subsec:21}.

This specific problem has the analytical eigenvalues \(\lambda = 3,7,11,15\)\citep{DepartmentofPhysics2019}.

\subsection{Eigenvalues of a two-electron Hamiltonian}\label{subsec:24}
The radial equation for a non-interacting electron pair, can be written as the product of two single-electron radial equations
$$
	\left(-\frac{\hbar^{2}}{m}\frac{d^{2}}{dr^{2}}-
	\frac{\hbar^{2}}{4m}\frac{d^{2}}{dR^{2}}+\frac{1}{4}kr^{2}+kR^{2}\right)u(r,R) =
	E^{2}u(r,R),
$$
where \(r = r_{1}-r_{2}\) is the difference between the radial coordinates of the two electrons, and \(R = \frac{1}{2}(r_{1}+r_{2})\) is the coordinate of the center of mass\citep{DepartmentofPhysics2019}.

By seperating the radial wavefunction \(u(r,R) = \psi(r)\phi(R)\), and adding in the repulsive Coloumb interaction between the electrons \(V(r)=\beta e^{2}/r\), where \(\beta\)is a konstant and \(e\) is the electron charge, the \(r\)-dependent Scroedinger equation becomes
$$
	-\frac{d^{2}}{d\rho^{2}}\psi(\rho)+\omega_{r}^{2}\rho^{2}\psi(\rho)+\frac{1}{\rho}=
	\lambda\psi(\rho),
$$ 
where \(\rho\in[0,\infty)\) is the same dimensionless variable from \autoref{subsec:23}, the frequency \(\omega_{r}=\frac{1}{4}\frac{mk}{\hbar^{2}}\alpha^{4}\), \(\alpha\) is chosen such that
\(\frac{m\alpha\beta e^{2}}{\hbar^{2}}=1\), and \(\lambda = \frac{m\alpha^{2}}{\hbar^{2}}E\)\citep{DepartmentofPhysics2019}.

Doing the same discretization as in \autoref{subsec:21} and \autoref{subsec:23} results in the linear equations
$$
	-\frac{1}{h^{2}}u_{i+1}+
	\left(\frac{2}{h^{2}}+\omega_{r}^{2}\rho^{2}+\frac{1}{\rho}\right)u_{i}-
	\frac{1}{h^{2}}u_{i-1}=\lambda u_{i},
$$
and a tridiagonal matrix \(A\) with diagonal elements \(d=\left(\frac{2}{h^{2}}+\omega_{r}^{2}\rho^{2}+\frac{1}{\rho}\right)\) and non-diagonal elements \(e=-\frac{1}{h^{2}}\). The step-size \(h\) is defined as in \autoref{subsec:21}.

This wave equation has analytical eigenvalues for certain \(\omega_{r}\) as described in Taut, M.'s paper in Physical Review (1993) \citep{PhysRevA.48.3561}.

\section{Implementation}\label{sec:3}
\subsection{Constructing the matrix and testing agianst the NumPy solver}\label{subsec:31}
As a prequel to implementing the jacobi algorithm, \hyperref[A:1]{"program.py"} was written to construct the tridiagonal Toeplitz matrix, and find its eigenvalues using the numpy.linalg.eig() method provided by the NumPy package. \hyperref[A:1]{"program.py"} also includes a test comparing the numerically found eigenvalues with the expected results from the analytical expression in \autoref{subsec:22}, with a tolerance of \(10^{-10}\).

\subsection{Implementing Jacobi's rotational algorithm}\label{subsec:32}
Jacobi's algorithm was implemented in \hyperref[A:2]{"jacobi.py"}. The afformentioned program takes in a value \(N\), and sets up the parameters as well as creating the Toeplitz matrix using the function from \hyperref[A:1]{"program.py"}. A mask is created and used when calculating the norm of the non-diagonal elements in the matrix. The jacobi function is called, returning the diagonal elements.

The jacobi function consists of a while-loop that runs until the norm of the non-diagonal elements are less than a tolerance of \(10^{-20}\). The loops starts by finding \(a_{kl}\) with the maximum absolute value, then uses the returned indices to retrive the \(a_{kk}\), and \(a_{ll}\). The parameters \(\tau,t,c,s\) are all calculated, with \(t\) being chosen such that \(|\theta|\leq\frac{\pi}{4}\) to ensure minimal difference between \(A\) and \(B\)\citep{Hjorth-Jensen2019}.

Furthermore, a for-loop is started that runs through \(A\) and calculates the non-diagonal elements except for \(b_{kl},b_{lk},b_{ll},b_{kk}\). After the for-loop finishes, the remaining matrix elements are calculated, as well as the new norm of the non-diagonal elements, and the while-loop has completed one full loop.

When the norm of the non-diagonal elements is below the set tolerance, the while-loop finishes, and the matrix \(B\) is returned by the function.

The find\_max function in \hyperref[A:2]{"jacobi.py"} uses two nested for-loops to run over every non-diagonal element in \(A\) and check if the current element has a larger absolute value than the previously stored \(a_{kl}\), with the starting value being \(a_{kl} = 0\). Once a valid value is found, it is stored and used to evaluate the remaining elements until it is replaced with a new maximum, or the loops end. The new \(a_{kl}\) is then returned together with the indices \(k,l\).

Finally, the numerical eigenvalues are extracted, sorted and printed to the terminal.

The program files also includes \hyperref[A:5]{"unittest.py"}, which tests the corespondence between the numerical eigenvalues found using the jacobi function on the tridiagonal matrix from \autoref{subsec:21}, and the analytical eigenvalues, with a tolerance of \(10^{-10}\). A second unit test in \hyperref[A:5]{"unittest.py"} tests if the find\_max function is able to always pick out the element with the largest absolute value in a randomized \(5\times5\)-matrix.

\subsection{Implementing the single-electron problem}\label{subsec:33}
To solve the eigenvalues of the problem outlined in \autoref{subsec:23}, \hyperref[A:3]{"oneelectron.py"} was written. The program takes in the number of grid points. Ten it sets the maximum value \(\rho_{N}\approx\infty\) of \(\rho\), which after trial and error was determined to be \(12.5\), with the computational resources I had available.

The step-size, and matrix elements are calculated, and the matrix is created, as well as a mask that conceals the diagonal when evaluating the norm of \(A\). The matrix is diagonalized using the jacobi function from \hyperref[A:2]{"jacobi.py"}, and the eigenvalues are retrieved.

Finally, the program prints the eigenvalues, as well as their relative errors.

\subsection{Implementing the two-electron problem}\label{subsec:34}
The implementation of the problem outlined in \autoref{subsec:24} is almost identical to the implementation in \autoref{subsec:33}, and can be found in \hyperref[A:4]{"twoelectron.py"}. The difference is in the diagonal elements of \(A\), and that \hyperref[A:4]{"twoelectron.py"} does not calculate the relative error of the eigenvalues.

\section{Analysis}\label{sec:4}
\subsection{Results from testing the NumPy solver on the buckeling beam problem}\label{subsec:41}
\begin{table}[H]
	\label{tab:411}
	\centering
	\begin{tabular}{|c|c|}
	Numerical eigenvalue & Analytical eigenvalue \\
	\(6.69872981\)	& \(6.69872981\) \\
	\(25\) & \(25\) \\
	\(50\) & \(50\) \\
	\(75\) & \(75\) \\
	\(93.30127019\) & \(93.30127019\) \\
	\end{tabular}
	\caption{Numerical and analytical eigenvalues of the tridiagonal Toeplitz matrix for
	the buckling beam problem, using the NumPy solver. \(N=5\)}
\end{table}

\hyperref[tab:411]{Table I} shows the resulting numerical, and analytical eigenvalues of \hyperref[A:1]{"program.py"} being run with \(N=5\). The NumPy solver could handle up to and including \(N=79\), before exceeding the tolerance of \(10^{-10}\) with a maximum error of \(\SI{1.382432e-10}{}\). With \(N=10^{3}\), which was the highest tested, the maximum error was only \(\SI{4.097819e-08}{}\).

\subsection{Results of implementing the buckling beam problem using Jacobi's algorithm}\label{subsec:42}
\begin{table}[H]
	\label{tab:421}
	\centering
	\begin{tabular}{|c|c|}
	Numerical eigenvalue & Analytical eigenvalue \\
	\(6.69872981\)	& \(6.69872981\) \\
	\(25\) & \(25\) \\
	\(50\) & \(50\) \\
	\(75\) & \(75\) \\
	\(93.30127019\) & \(93.30127019\) \\
	\end{tabular}
	\caption{Numerical and analytical eigenvalues of the tridiagonal Toeplitz matrix for
	the buckling beam problem, using the \hyperref[A:2]{jacobi.py} solver. \(N=5\)}
\end{table}
\hyperref[tab:421]{Table II} shows the resulting numerical, and analytical eigenvalues of \hyperref[A:2]{"jacobi.py"} being run with \(N=5\). The \hyperref[A:2]{jacobi.py} solver could handle up to and including \(N=5\), before exceeding the tolerance of \(10^{-10}\) with a maximum error of \(\SI{1.145963e-10}{}\). With \(N=200\), which was the highest tested, the maximum error was \(\SI{5.587935e-09}{}\).

\subsection{Results of the single-electron problem with Jacobi's algorithm}\label{subsec:43}
\begin{table}[H]
	\label{tab:431}
	\centering
	\begin{tabular}{|c|c|c|}
	Numerical eigenvalue & Analytical eigenvalue & Relative error \\
	\(3.01384183\)	& \(3\) & \(0.00461394\) \\
	\(7.02900535\) & \(7\) & \(0.00414362\) \\
	\(11.04021305\) & \(11\) & \(0.00365573\) \\
	\(15.04745905\) & \(15\) & \(0.00316394\) \\
	\end{tabular}
	\caption{Numerical and analytical eigenvalues of the Hamiltonian for
	the single electron problem, using the \hyperref[A:2]{jacobi.py} solver. \(N=200\),
	\(\rho_{N}=12.5\)}
\end{table}
\begin{table}[H]
	\label{tab:432}
	\centering
	\begin{tabular}{|c|c|c|}
	Numerical eigenvalue & Analytical eigenvalue & Relative error \\
	\(3.04073901\)	& \(3\) & \(0.01357967\) \\
	\(7.0396407\) & \(7\) & \(0.00566296\) \\
	\(10.97051694\) & \(11\) & \(0.00268028\) \\
	\(14.83148019\) & \(15\) & \(0.01123465\) \\
	\end{tabular}
	\caption{Numerical and analytical eigenvalues of the Hamiltonian for
	the single electron problem, using the \hyperref[A:2]{jacobi.py} solver. \(N=50\),
	\(\rho_{N}=12.5\)}
\end{table}
\begin{table}[H]
	\label{tab:433}
	\centering
	\begin{tabular}{|c|c|c|}
	Numerical eigenvalue & Analytical eigenvalue & Relative error \\
	\(3.01476709\)	& \(3\) & \(0.00492236\) \\
	\(7.03363428\) & \(7\) & \(0.0048049\) \\
	\(11.05151444\) & \(11\) & \(0.00468313\) \\
	\(15.06840746\) & \(15\) & \(0.0045605\) \\
	\end{tabular}
	\caption{Numerical and analytical eigenvalues of the Hamiltonian for
	the single electron problem, using the \hyperref[A:2]{jacobi.py} solver. \(N=200\),
	\(\rho_{N}=6.25\)}
\end{table}
\begin{table}[H]
	\label{tab:434}
	\centering
	\begin{tabular}{|c|c|c|}
	Numerical eigenvalue & Analytical eigenvalue & Relative error \\
	\(3.05613118\)	& \(3\) & \(0.01871039\) \\
	\(7.11734334\) & \(7\) & \(0.01676333\) \\
	\(11.16211274\) & \(11\) & \(0.01473752\) \\
	\(15.190338\) & \(15\) & \(0.0126892\) \\
	\end{tabular}
	\caption{Numerical and analytical eigenvalues of the Hamiltonian for
	the single electron problem, using the \hyperref[A:2]{jacobi.py} solver. \(N=50\),
	\(\rho_{N}=6.25\)}
\end{table}
By comparing \hyperref[tab:431]{table III}, \hyperref[tab:432]{table IV}, \hyperref[tab:433]{table V}, and \hyperref[tab:434]{table VI}, it appears that adjusting \(N\) has the most noticable effect on the accuracy of the \hyperref[A:2]{jacobi.py} solver. I was unable to push the accuracy further, due to the limited single-core performance of the hardware that was used.

\subsection{Results of the single-electron problem with Jacobi's algorithm}\label{subsec:44}
\begin{table}[H]
	\label{tab:441}
	\centering
	\begin{tabular}{|c|c|}
	Numerical eigenvalue & \(\omega_{r}\) \\
	\(0.16645674\)	& \(0.01\) \\
	\(1.2501149\) & \(0.25\) \\
	\(0.16645674\) & \(0.5\) \\
	\(4.07545554\) & \(1.0\) \\
	\end{tabular}
	\caption{Numerical eigenvalues of the Hamiltonian for
	the two-electron problem, using the \hyperref[A:2]{jacobi.py} solver. \(N=100\),
	\(\rho_{N}=15.794\)}
\end{table}
\hyperref[tab:441]{Table VII} shows the lowest eigenvalues of the two-electron problem outlined in \autoref{subsec:24} calculated using the \hyperref[A:2]{jacobi.py} solver. The values of \(N\), and \(\rho_{N}\) was chosen by trying to make the value for \(\omega_{r}=0.25\) match the value of \(0.5\lambda=0.625\) found by Taut, M. (1993) (see Table I for \(n=4\) in \citep{PhysRevA.48.3561}), which is not the lowest eigenvalue. However, this was not a reliable way of adjusting parameters, as a slight nudge gave significantly different results. Perhaps if the implementation of Jacobi's algorithm was better optimized, and/or the hardware running the calculation was better, I could have achieved more reliable results.

The remaining values in \hyperref[tab:441]{table VII} shows the lowest eigenvalue, and presumably the ground state energy.

\subsection{Discussion of implementation}\label{subsec:45}
Overall, my implementation of \hyperref[subsec:32]{Jacobi's algorithm} is not particularly resource efficient. Possible improvements include looking for terms, and factors that can be precalculated to reduce the number of FLOPS, as well as other possible ways to store the matrix than as a \(2D\)-NumPy array, seeing as this stores a lot of \(0\)-elements in memory that will never be used in calculations.

Furthermore, rewriting the jacobi function to make it compatible with the Numba jit-compiler's nopyhton-mode, so as to take full advantae of the jit-compiler. Alternativly, implimenting the algorithm in a lower-level programming language than Python 3.6, such as c++, would likely speed up the calculations. I would also look at the way the step-size is implemented, as I am unsure if I have understood the definition correctly.

Overall, the implementation seems usable for problems that have a finite max value for their function variable \(\rho_{N}\). While implimentations that require a sufficently large \(\rho_{N}\approx\infty\), would require hardware with better computing recourses, such that a matching sufficiently large \(N\) can be used. Otherwise it is hard to get reliable results with high accuracy.

\section{Conclusion}\label{sec:5}
The implementation of \hyperref[subsec:32]{Jacobi's algorithm} looked at in this paper, was able to calulate the eigenvalues of the \hyperref[subsec:21]{buckling beam} problem with high accuracy as seen in \hyperref[tab:421]{table II}, but could only reproduce the eigenvalues of the \hyperref[subsec:23]{single-electron} problem within \(2\) leading decimals.

Furthermore, the implementation could reproduce one of the results from Taut, M. (1993)\citep{PhysRevA.48.3561} to \(3\) leading decimals. However, the reliability of this result is suspect at best.

Overall, my implementation of \hyperref[subsec:32]{Jacobi's algorithm} is not particularly resource efficient. There are several improvements that can be made in future implementations. The implementation discussed in this paper can be used somewhat reliably for problems with a finite maximum variable, for \(N \leq 200\), but require to be run on better hardware to allow higher \(N\) if the problem beeing solved requires the maximum variable to approximate infinity.

\bibliography{kilder}{}

\newpage
\appendix
\section{Program files} \label{A}
All code for this report was written in Python 3.6, and the complete set of program files can be found at \url{https://github.com/FunkMarvel/CompPhys-Project-2}.

\subsection{program.py}\label{A:1}
\url{https://github.com/FunkMarvel/CompPhys-Project-2/blob/master/program.py}

\subsection{jacobi.py}\label{A:2}
\url{https://github.com/FunkMarvel/CompPhys-Project-2/blob/master/jacobi.py}

\subsection{oneelectron.py} \label{A:3}
\url{https://github.com/FunkMarvel/CompPhys-Project-2/blob/master/oneelectron.py}

\subsection{twoelectron.py} \label{A:4}
\url{https://github.com/FunkMarvel/CompPhys-Project-2/blob/master/twoelectron.py}

\subsection{unittest.py}\label{A:5}
\url{https://github.com/FunkMarvel/CompPhys-Project-2/blob/master/unittests.py}


\end{document}
