\documentclass[english,notitlepage,reprint]{revtex4-1}  % defines the basic parameters of the document

% if you want a single-column, remove reprint

% allows special characters (including æøå)
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

%% note that you may need to download some of these packages manually, it depends on your setup.
%% I recommend downloading TeXMaker, because it includes a large library of the most common packages.

\usepackage{physics,amssymb}  % mathematical symbols (physics imports amsmath)
\usepackage{graphicx}         % include graphics such as plots
\usepackage{xcolor}           % set colors
\usepackage{hyperref}         % automagic cross-referencing (this is GODLIKE)
\usepackage{tikz}             % draw figures manually
\usepackage{listings}         % display code
\usepackage{subfigure}        % imports a lot of cool and useful figure commands
\usepackage{lipsum}

\usepackage{lmodern}

% (2) specify encoding
\usepackage[T1]{fontenc}
\usepackage{textcomp}
%\usepackage{unicode-math}
\usepackage{float}
\usepackage{balance}

% defines the color of hyperref objects
% Blending two colors:  blue!80!black  =  80% blue and 20% black
\hypersetup{ % this is just my personal choice, feel free to change things
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}}

%% Defines the style of the programming listing
%% This is actually my personal template, go ahead and change stuff if you want
\lstset{ %
	inputpath=,
	backgroundcolor=\color{white!88!black},
	basicstyle={\ttfamily\scriptsize},
	commentstyle=\color{magenta},
	language=Python,
	morekeywords={True,False},
	tabsize=4,
	stringstyle=\color{green!55!black},
	frame=single,
	keywordstyle=\color{blue},
	showstringspaces=false,
	columns=fullflexible,
	keepspaces=true}

\lstset{literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}

%% USEFUL LINKS:
%%
%%   UiO LaTeX guides:        https://www.mn.uio.no/ifi/tjenester/it/hjelp/latex/
%%   mathematics:             https://en.wikibooks.org/wiki/LaTeX/Mathematics

%%   PHYSICS !                https://mirror.hmc.edu/ctan/macros/latex/contrib/physics/physics.pdf

%%   the basics of Tikz:       https://en.wikibooks.org/wiki/LaTeX/PGF/TikZ
%%   all the colors!:          https://en.wikibooks.org/wiki/LaTeX/Colors
%%   how to draw tables:       https://en.wikibooks.org/wiki/LaTeX/Tables
%%   code listing styles:      https://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings
%%   \includegraphics          https://en.wikibooks.org/wiki/LaTeX/Importing_Graphics
%%   learn more about figures  https://en.wikibooks.org/wiki/LaTeX/Floats,_Figures_and_Captions
%%   automagic bibliography:   https://en.wikibooks.org/wiki/LaTeX/Bibliography_Management  (this one is kinda difficult the first time)
%%   REVTeX Guide:             http://www.physics.csbsju.edu/370/papers/Journal_Style_Manuals/auguide4-1.pdf
%%
%%   (this document is of class "revtex4-1", the REVTeX Guide explains how the class works)


%% CREATING THE .pdf FILE USING LINUX IN THE TERMINAL
%%
%% [terminal]$ pdflatex template.tex
%%
%% Run the command twice, always.
%% If you want to use \footnote, you need to run these commands (IN THIS SPECIFIC ORDER)
%%
%% [terminal]$ pdflatex template.tex
%% [terminal]$ bibtex template
%% [terminal]$ pdflatex template.tex
%% [terminal]$ pdflatex template.tex
%%
%% Don't ask me why, I don't know.

\usepackage{thmtools}
\DeclareMathOperator{\nullspace}{Nul}
\DeclareMathOperator{\collspace}{Col}
\DeclareMathOperator{\rref}{Rref}
%%\DeclareMathOperator{\dim}{Dim}

 % "meq": must be equal
\newcommand{\meq}{\overset{!}{=}}

\newcommand{\R}{\mathbb{R}}
\newcommand*\Heq{\ensuremath{\overset{\kern2pt L'H}{=}}}
\usepackage{bm}
\newcommand{\uveci}{{\bm{\hat{\textnormal{\bfseries\i}}}}}
\newcommand{\uvecj}{{\bm{\hat{\textnormal{\bfseries\j}}}}}
\DeclareRobustCommand{\uvec}[1]{{%
  \ifcsname uvec#1\endcsname
     \csname uvec#1\endcsname
   \else
    \bm{\hat{\mathbf{#1}}}%
   \fi
}}
\usepackage{siunitx}

\makeatletter
\newcommand*{\balancecolsandclearpage}{%
  \close@column@grid
  \cleardoublepage
  \twocolumngrid
}
\makeatother

\newcounter{subproject}
\renewcommand{\thesubproject}{\alph{subproject}}
\newenvironment{subproj}{
\begin{description}
	\item[\refstepcounter{subproject}(\thesubproject)]
}{\end{description}}


\begin{document}
\title{Calculating eigenvalues using Jacobi's rotational algorithm}   % self-explanatory
\author{Anders P. Åsbø}               % self-explanatory
\date{\today}
\noaffiliation                            % ignore this

\begin{abstract}
The focus of this paper was the specific
\end{abstract}

\maketitle
\tableofcontents

\section{Introduction}\label{sec:1}
The focus of this paper was the implementation, and application of Jacobi's rotational algorithm to find the eigenvalues of Tridiagonal matrices numerically. Reliably finding eigenvalues is a crucial part of many scientific and mathematical disciplines. In this paper I considered the quantum mechanical application of electrons trapped in a harmonic oscillator potential.

\section{Formalism}\label{sec:2}
\subsection{The buckling beam problem}\label{subsec:21}
The pretense for implementing Jacobi's algorithm is the classical problem of a beam of length \(L\) fastened in both ends \(x_{0} = 0\), \(x_{L} = L\). The beam is allowed to be displaced in the \(y\)-direction with displacement \(u(x)\), while \(u(0)=u(L)=0\). The displacement is driven by a force \(F\) at \((L,0)\) towards the origin. The displacement is then described by
$$
	\gamma \frac{d^{2}u(x)}{dx^{2}}=-Fu(x),
$$
where \(\gamma\) is a constant dependent on the physical properties of the beam\citep{DepartmentofPhysics2019}.

By scaling the differential equation with \(\rho = \frac{x}{L}\), such that \(\rho \in [0,1]\), and introducing the parameter \(\lambda = FL^{2}/\gamma\)\citep{DepartmentofPhysics2019}, the differential equation becomes
$$
	\frac{d^{2}u(\rho)}{d\rho^{2}}=-\lambda u(\rho).
$$

Finally, the equation can be discretized with
$$
	u'' \approx \frac{u(\rho+h)-2u(\rho)+u(\rho-h)}{h^{2}},
$$
where \(h = \frac{\rho_{N}-\rho_{0}}{N}\) with \(N\) steps\citep{DepartmentofPhysics2019}. The resulting discretization becomes
$$
	-\frac{1}{h^{2}}u_{i+1}+
	\frac{2}{h^{2}}u_{i}-\frac{1}{h^{2}}u_{i-1}=\lambda u_{i},
$$
which can be written as the matrix equation
$$
	A\vec{u}=\lambda\vec{u},
$$
where \(A\) is an \((N-2)\times (N-2)\) tridiagonal Toeplitz matrix with the diagonal elements \(d=2/h^{2}\), and upper and lower diagonals with elements \(a=-1/h^{2}\). This matrix happens to have analytical eigenvalues
$$
	\lambda_{j}=d+2a\cos\left(\frac{j\pi}{N+1}\right),
$$
where \(j=1,2,...,N\)\citep{DepartmentofPhysics2019}.

\subsection{The Jacobi rotational algorithm}\label{subsec:22}
The goal of the Jacobi rotational algorithm is to reduce a matrix \(A\) to a diagonal matrix \(B\) where the elements along the diagonal are the eigenvalues \(\lambda_{i}\) of \(A\). This is usually done by finding a matrix \(S\) such that
$$
	B = S^{T}AS,
$$
and \(S^{T}=S^{-1}\)\citep{Hjorth-Jensen2019}. The Jacobi algorithm achieves this by choosing the elements of \(S\) to be equal to the coresponding identity matrix, except for the elements \(s_{kk},s_{ll}=\cos\theta\) and \(s_{kl} = \pm \sin\theta\), \(s_{lk} = -s_{kl}\)\citep{Hjorth-Jensen2019}, and applying the \(B = S^{T}AS\) transformation repeatedly, until the non-diagonal elements of \(B\) are sufficiently close to zero. Doing this we get a system of equations for the various elements of the resulting matrix \(B\)
$$
	b_{ii}=a_{ii} i\neq k, i\neq l,
$$
$$
	b_{ik}=a_{ik}c-a_{il}s, i\neq k, i\neq l,
$$
$$
	b_{il}=a_{il}c+a_{ik}s, i\neq k, i\neq l,
$$
$$
	b_{kk}=a_{kk}c^{2}-2a_{kl}cs-a_{ll}s^{2},
$$
$$
	b_{ll}=a_{ll}c^{2}-2a_{kl}cs-a_{kk}s^{2},
$$
$$
	b_{kl}=\left(a_{kk}-a_{ll}\right)cs-a_{kl}\left(c^{2}-s^{2}\right),
$$
$$
	b_{lk}=-b_{kl},
$$
where \(c = \cos\theta\), \(s = \sin\theta\), and \(k,l\) are chosen such that \(a_{kl}\) is the non-diagonal element in \(A\) with the largest absolute value.

To chose an rotational angle \(\theta\), the quantities \(\tan\theta=t=s/c\) are defined such that
$$
	\cot 2\theta = \tau = \frac{a_{ll}-a_{kk}}{2a_{kl}},
$$
$$
	t = -\tau \pm \sqrt{1+\tau^{2}},
$$
$$
	c = \frac{1}{\sqrt{1+t^{2}}},
$$
$$
	s = ct,
$$
\citep{Hjorth-Jensen2019}.

\subsection{Eigenvalues of a one-electron Hamiltonian}\label{subsec:23}
To test the implimentation of Jacobi's algorithm, as outlined in \autoref{subsec:22}, a quantum mechanical system consisting of an electron trapped in a radialy symetric harmonic oscillator potential \(V(r)=\frac{1}{2}mkr^{2}\) was chosen as a test case.
the corresponding radial equation is
$$
	-\frac{\hbar^{2}}{2m}\left(\frac{1}{r^{2}}\frac{d}{dr}r^{2}\frac{d}{dr}-\frac{l\left(l+1\right)}{r^{2}}\right)R(r)+V(r)R(r)=ER(r),
$$
where \(\hbar\) is Planck's constant, \(m\) is the electron mass, \(R(r)\) is the radial wavefunction,  and \(l=0,1,2,3,...\) is the orbital momentum of the electron\citep{DepartmentofPhysics2019}. By substituting in \(R(r) = (1/r)u(r)\), and introducing the scaled variable \(\rho = (1/\alpha)r\), where \(\alpha\) is some constant, the equation can be reduced to
$$
	-\frac{d^{2}}{d\rho^{2}}u(\rho)+\rho^{2}u(\rho)=\lambda u(\rho),
$$
where \(\alpha\) is chosen such that \(\frac{mk}{\hbar^{2}}\alpha^{4} = 1\), and
$$
	\lambda=\frac{2m\alpha^{2}}{\hbar^{2}}
$$
\citep{DepartmentofPhysics2019}.

After discretization as in \autoref{subsec:21}, the problem results in the system of linear equations
$$
	-\frac{1}{h^{2}}u_{i+1}+
	\left(\frac{2}{h^{2}}+\rho^{2}\right)u_{i}-\frac{1}{h^{2}}u_{i-1}=\lambda u_{i},
$$
with the requirement that \(u(0)=u(\infty)=0\)\citep{DepartmentofPhysics2019}. This can be written as a matrix equation where the matrix \(A\) is a tridiagonal matrix with \(d = \left(\frac{2}{h^{2}}+\rho^{2}\right)\) along the diagonal, and \(e = -\frac{1}{h^{2}}\) as the non-diagonal elements. The step-size \(h\) is as defined in \autoref{subsec:21}.

This specific problem has the analytical eigenvalues \(\lambda = 3,7,11,15\)\citep{DepartmentofPhysics2019}.

\subsection{Eigenvalues of a two-electron Hamiltonian}\label{subsec:24}
The radial equation for a non-interacting electron pair, can be written as the product of two single-electron radial equations
$$
	\left(-\frac{\hbar^{2}}{m}\frac{d^{2}}{dr^{2}}-
	\frac{\hbar^{2}}{4m}\frac{d^{2}}{dR^{2}}+\frac{1}{4}kr^{2}+kR^{2}\right)u(r,R) =
	E^{2}u(r,R),
$$
where \(r = r_{1}-r_{2}\) is the difference between the radial coordinates of the two electrons, and \(R = \frac{1}{2}(r_{1}+r_{2})\) is the coordinate of the center of mass\citep{DepartmentofPhysics2019}.

By seperating the radial wavefunction \(u(r,R) = \psi(r)\phi(R)\), and adding in the repulsive Coloumb interaction between the electrons \(V(r)=\beta e^{2}/r\), where \(\beta\)is a konstant and \(e\) is the electron charge, the \(r\)-dependent Scroedinger equation becomes
$$
	-\frac{d^{2}}{d\rho^{2}}\psi(\rho)+\omega_{r}^{2}\rho^{2}\psi(\rho)+\frac{1}{\rho}=
	\lambda\psi(\rho),
$$ 
where \(\rho\in[0,\infty)\) is the same dimensionless variable from \autoref{subsec:23}, the frequency \(\omega_{r}=\frac{1}{4}\frac{mk}{\hbar^{2}}\alpha^{4}\), \(\alpha\) is chosen such that
\(\frac{m\alpha\beta e^{2}}{\hbar^{2}}=1\), and \(\lambda = \frac{m\alpha^{2}}{\hbar^{2}}E\)\citep{DepartmentofPhysics2019}.

Doing the same discretization as in \autoref{subsec:21} and \autoref{subsec:23} results in the linear equations
$$
	-\frac{1}{h^{2}}u_{i+1}+
	\left(\frac{2}{h^{2}}+\omega_{r}^{2}\rho^{2}+\frac{1}{\rho}\right)u_{i}-
	\frac{1}{h^{2}}u_{i-1}=\lambda u_{i},
$$
and a tridiagonal matrix \(A\) with diagonal elements \(d=\left(\frac{2}{h^{2}}+\omega_{r}^{2}\rho^{2}+\frac{1}{\rho}\right)\) and non-diagonal elements \(e=-\frac{1}{h^{2}}\). The step-size \(h\) is defined as in \autoref{subsec:21}.

This wave equation has analytical eigenvalues for certain \(\omega_{r}\) as described in Taut, M.'s paper in Physical Review (1993) \citep{PhysRevA.48.3561}.

\section{Implementation}\label{sec:3}
\subsection{Constructing the matrix and testing agianst the NumPy solver}\label{subsec:31}
As a prequel to implementing the jacobi algorithm, \hyperref[A:1]{"program.py"} was written to construct the tridiagonal Toeplitz matrix, and find its eigenvalues using the numpy.linalg.eig() method provided by the NumPy package. \hyperref[A:1]{"program.py"} also includes a test comparing the numerically found eigenvalues with the expected results from the analytical expression in \autoref{subsec:22}, with a tolerance of \(10^{-10}\).

\subsection{Implementing Jacobi's rotational algorithm}\label{subsec:32}
Jacobi's algorithm was implemented in \hyperref[A:2]{"jacobi.py"}. The afformentioned program takes in a value \(N\), and sets up the parameters as well as creating the Toeplitz matrix using the function from \hyperref[A:1]{"program.py"}. A mask is created and used when calculating the norm of the non-diagonal elements in the matrix. The jacobi function is called, returning the diagonal elements.

The jacobi function consists of a while-loop that runs until the norm of the non-diagonal elements are less than a tolerance of \(10^{-20}\). The loops starts by finding \(a_{kl}\) with the maximum absolute value, then uses the returned indices to retrive the \(a_{kk}\), and \(a_{ll}\). The parameters \(\tau,t,c,s\) are all calculated, with \(t\) being chosen such that \(|\theta|\leq\frac{\pi}{4}\) to ensure minimal difference between \(A\) and \(B\)\citep{Hjorth-Jensen2019}.

Furthermore, a for-loop is started that runs through \(A\) and calculates the non-diagonal elements except for \(b_{kl},b_{lk},b_{ll},b_{kk}\). After the for-loop finishes, the remaining matrix elements are calculated, as well as the new norm of the non-diagonal elements, and the while-loop has completed one full loop.

When the norm of the non-diagonal elements is below the set tolerance, the while-loop finishes, and the matrix \(B\) is returned by the function.

The find\_max function in \hyperref[A:2]{"jacobi.py"} uses two nested for-loops to run over every non-diagonal element in \(A\) and check if the current element has a larger absolute value than the previously stored \(a_{kl}\), with the starting value being \(a_{kl} = 0\). Once a valid value is found, it is stored and used to evaluate the remaining elements until it is replaced with a new maximum, or the loops end. The new \(a_{kl}\) is then returned together with the indices \(k,l\).

Finally, the numerical eigenvalues are extracted, sorted and printed to the terminal.

The program files also includes \hyperref[A:5]{"unittest.py"}, which tests the corespondence between the numerical eigenvalues found using the jacobi function on the tridiagonal matrix from \autoref{subsec:21}, and the analytical eigenvalues, with a tolerance of \(10^{-10}\). A second unit test in \hyperref[A:5]{"unittest.py"} tests if the find\_max function is able to always pick out the element with the largest absolute value in a randomized \(5\times5\)-matrix.

\subsection{Implementing the single-electron problem}
To solve the eigenvalues of the problem outlined in \autoref{subsec:23}, \hyperref[A:3]{"oneelectron.py"} was written. The program takes in the number of grid points. Ten it sets the maximum value \(\rho_{N}\approx\infty\) of \(\rho\), which after trial and error was determined to be \(12.5\), with the computational resources I had available. The step-size, and matrix elements are calculated, and the matrix created, as well as a mask that conceals the diagonal when evaluating the norm of \(A\). The matrix is diagonalized, and the eigenvalues are retrieved.

\section{Analysis}\label{sec:4}



\section{Conclusion}\label{sec:5}

\bibliography{kilder}{}
\newpage
\appendix
\section{Program files} \label{A}
All code for this report was written in Python 3.6, and the complete set of program files can be found at \url{https://github.com/FunkMarvel/CompPhys-Project-2}.

\subsection{program.py}\label{A:1}
\url{https://github.com/FunkMarvel/CompPhys-Project-2/blob/master/program.py}

\subsection{jacobi.py}\label{A:2}
\url{https://github.com/FunkMarvel/CompPhys-Project-2/blob/master/jacobi.py}

\subsection{oneelectron.py} \label{A:3}
\url{https://github.com/FunkMarvel/CompPhys-Project-2/blob/master/oneelectron.py}

\subsection{twoelectron.py} \label{A:4}
\url{https://github.com/FunkMarvel/CompPhys-Project-2/blob/master/twoelectron.py}

\subsection{unittest.py}\label{A:5}
\url{https://github.com/FunkMarvel/CompPhys-Project-2/blob/master/unittests.py}


\end{document}
